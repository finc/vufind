import org.marc4j.marc.Record;
import org.marc4j.marc.DataField;
import org.solrmarc.index.UpdateDateTracker;
import org.ini4j.Ini;
import java.util.Arrays;

// define the base level indexer so that its methods can be called from the script.
// note that the SolrIndexer code will set this value before the script methods are called.
org.solrmarc.index.SolrIndexer indexer = null;

/**
 * Check if a particular Datafield meets the specified relator requirements.
 * @param authorField      Field to analyze
 * @param noRelatorAllowed Array of tag names which are allowed to be used with
 * no declared relator.
 * @param relatorConfig    The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @return Boolean
 */
public Boolean authorHasAppropriateRelator(DataField authorField,
    String[] noRelatorAllowed, String relatorConfig
) {
    // get tag number from Field
    String tag = authorField.getTag();
    List subfieldE = normalizeRelatorSubfieldList(authorField.getSubfields('e'));
    List subfield4 = normalizeRelatorSubfieldList(authorField.getSubfields('4'));

    // if no relator is found, check to see if the current tag is in the "no
    // relator allowed" list.
    if (subfieldE.size() == 0 && subfield4.size() == 0) {
        return Arrays.asList(noRelatorAllowed).contains(tag);
    }

    // If we got this far, we need to figure out what type of relation they have
    List permittedRoles = normalizeRelatorStringList(Arrays.asList(loadRelatorConfig(relatorConfig)));
    for (int j = 0; j < subfield4.size(); j++) {
        if (permittedRoles.contains(subfield4.get(j).getData())) {
            return true;
        }
    }
    for (int j = 0; j < subfieldE.size(); j++) {
        if (permittedRoles.contains(subfieldE.get(j).getData())) {
            return true;
        }
    }
    return false;
}

/**
 * Parse a SolrMarc fieldspec into a map of tag name to set of subfield strings
 * (note that we need to map to a set rather than a single string, because the
 * same tag may repeat with different subfields to extract different sections
 * of the same field into distinct values).
 *
 * @param tagList The field specification to parse
 * @returns HashMap
 */
public HashMap getParsedTagList(String tagList)
{
    String[] tags = tagList.split(":");//convert string input to array
    HashMap tagMap = new HashMap();
    //cut tags array up into key/value pairs in hash map
    Set currentSet;
    for(int i = 0; i < tags.length; i++){
        String tag = tags[i].substring(0, 3);
        if (!tagMap.containsKey(tag)) {
            currentSet = new LinkedHashSet();
            tagMap.put(tag, currentSet);
        } else {
            currentSet = tagMap.get(tag);
        }
        currentSet.add(tags[i].substring(3));
    }
    return tagMap;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @param firstOnly            Return first result only?
 * @returns List result
 */
public List getAuthorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig, Boolean firstOnly
) {
    List result = new LinkedList();
    String[] noRelatorAllowed = acceptWithoutRelator.split(":");
    HashMap parsedTagList = getParsedTagList(tagList);
    List fields = indexer.getFieldSetMatchingTagList(record, tagList);
    Iterator fieldsIter = fields.iterator();
    if (fields != null){
        DataField authorField;
        while (fieldsIter.hasNext()){
            authorField = (DataField) fieldsIter.next();
            //add all author types to the result set
            if (authorHasAppropriateRelator(authorField, noRelatorAllowed, relatorConfig)) {
                for (String subfields : parsedTagList.get(authorField.getTag())) {
                    String current = indexer.getDataFromVariableField(authorField, "["+subfields+"]", " ", false);
                    // TODO: we may eventually be able to use this line instead,
                    // but right now it's not handling separation between the
                    // subfields correctly, so it's commented out until that is
                    // fixed.
                    //String current = authorField.getSubfieldsAsString(subfields);
                    if (null != current) {
                        result.add(current);
                        if (firstOnly) {
                            return result;
                        }
                    }
                }
            }
        }
    }
    return result;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @returns List result
 */
public List getAuthorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    // default firstOnly to false!
    return getAuthorsFilteredByRelator(
        record, tagList, acceptWithoutRelator, relatorConfig, false
    );
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for separating different types of authors.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @returns String
 */
public String getFirstAuthorFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    List result = getAuthorsFilteredByRelator(
        record, tagList, acceptWithoutRelator, relatorConfig, true
    );
    for (String s : result) {
        return s;
    }
    return null;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for saving relators of authors separated by different
 * types.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @param firstOnly            Return first result only?
 * @returns List result
 */
public List getRelatorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig, Boolean firstOnly,
    String defaultRelator
) {
    List result = new LinkedList();
    String[] noRelatorAllowed = acceptWithoutRelator.split(":");
    HashMap parsedTagList = getParsedTagList(tagList);
    List fields = indexer.getFieldSetMatchingTagList(record, tagList);
    Iterator fieldsIter = fields.iterator();
    if (fields != null){
        DataField authorField;
        while (fieldsIter.hasNext()){
            authorField = (DataField) fieldsIter.next();
            //add all author types to the result set
            if (authorHasAppropriateRelator(authorField, noRelatorAllowed, relatorConfig)) {
                List subfieldE = normalizeRelatorSubfieldList(authorField.getSubfields('e'));
                List subfield4 = normalizeRelatorSubfieldList(authorField.getSubfields('4'));
    
                // get the first non-empty subfield
                String relator = defaultRelator;

                // try subfield E first
                for (int j = 0; j < subfieldE.size(); j++) {
                    if (!subfieldE.get(j).getData().isEmpty()) {
                        relator = subfieldE.get(j).getData();
                        continue;
                    }
                }
                // try subfield 4 now and overwrite relator as subfield 4 is most important
                for (int j = 0; j < subfield4.size(); j++) {
                    if (!subfield4.get(j).getData().isEmpty()) {
                        relator = subfield4.get(j).getData();
                        continue;
                    }
                }

                result.add(relator);
            }
        }
    }
    return result;
}

/**
 * Filter values retrieved using tagList to include only those whose relator
 * values are acceptable. Used for saving relators of authors separated by different
 * types.
 *
 * @param record               The record (fed in automatically)
 * @param tagList              The field specification to read
 * @param acceptWithoutRelator Colon-delimited list of tags whose values should
 * be accepted even if no relator subfield is defined
 * @param relatorConfig        The setting in author-classification.ini which
 * defines which relator terms are acceptable (or a colon-delimited list)
 * @returns List result
 */
public List getRelatorsFilteredByRelator(Record record, String tagList,
    String acceptWithoutRelator, String relatorConfig
) {
    // default firstOnly to false!
    return getRelatorsFilteredByRelator(
        record, tagList, acceptWithoutRelator, relatorConfig, false, "default_relator"
    );
}

/**
 * This method fetches relator definitions from ini file and casts them to an
 * array. If a colon-delimited string is passed in, this will be directly parsed
 * instead of resorting to .ini loading.
 *
 * @param setting Setting to load from .ini or colon-delimited list.
 * @returns String[]
 */
public String[] loadRelatorConfig(String setting){
    String[] parts = setting.split(":");
    if (parts.length > 1) {
        return parts;
    }
    return indexer
        .getConfigSetting("author-classification.ini", "AuthorRoles", setting)
        .split(",");
}

/**
 * Normalizes the strings in a list.
 *
 * @param stringList List of strings to be normalized
 * @returns stringList Normalized List of strings 
 */
public List normalizeRelatorStringList(List stringList)
{
    for (int j = 0; j < stringList.size(); j++) {
        stringList.set(
            j,
            normalizeRelatorString(stringList.get(j))
        );
    }
    return stringList;
}

/**
 * Normalizes the strings in a list of subfields.
 *
 * @param subfieldList List of subfields to be normalized
 * @returns subfieldList Normalized List of subfields
 */
public List normalizeRelatorSubfieldList(List subfieldList)
{
    for (int j = 0; j < subfieldList.size(); j++) {
        subfieldList.get(j).setData(
            normalizeRelatorString(subfieldList.get(j).getData())
        );
    }
    return subfieldList;
}

/**
 * Normalizes a string
 *
 * @param string String to be normalized
 * @returns string
 */
public String normalizeRelatorString(String string)
{
    return string
        .trim()
        .toLowerCase()
        .replaceAll("\\p{Punct}+", "");    //POSIX character class Punctuation: One of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
}